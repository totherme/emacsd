* Emacs Configs

These are my personal emacs configs. In this branch, I'm trying a
minimalist setup, where every configuration choice is driven by a
use-case in this document.

This document is primarily. intended to be read in emacs, so some
hyperlinks may not work if you're reading in a web browser. For
example, I often link to internal emacs docs, help pages, and info
pages.

** Use Cases
*** Installing emacs packages
:PROPERTIES:
:ID:       52f1be7b-2b15-4b4c-84fa-ece5e2437c7b
:END:
While emacs ships with an enormous amount of cool stuff out of the
box, there are some extras we might want to install as well. For
example, [[id:0915af96-9c96-452c-aa7d-a2d2dc9b6fdd][we'd like to install Magit]].

Fortunately, emacs has [[info:emacs#Packages][a built in package management system]]. It can
download and install packages from a customisable list of /package
archives/, which are defined in the =package-archives= variable. By
default, that variable looks like this:
#+begin_src elisp :tangle no
(("gnu" . "https://elpa.gnu.org/packages/"))
#+end_src

This means we can download from the official gnu Emacs List Package
Archive (elpa). However, the bar for getting a package in there is
quite high, so we will often want to install from /Milkypostmanâ€™s
Emacs Lisp Package Archive/, or =melpa=.

There are two =melpa= archives, =melpa.org= and
=stable.melpa.org=. The former was the original =melpa=, but suffered
from packages that kept breaking in various ways. The stable archive
was introduced for folks who want to live a little less on the
bleeding edge. Generally speaking, packages in =melpa-stable= have
semantic version numbers, while packages in =melpa= are organised by
release-date rather than by version.

If possible I'd like to stick to the stable archive.

#+begin_src elisp
(require 'package)
(add-to-list 'package-archives
             '("melpa-stable" . "http://stable.melpa.org/packages/") t)
#+end_src

Now that we have access to a wider range of packages, we can install
things. However, doing so in code has a number of tedious edge-cases,
which are best handled by the =use-package= library. Which we will
first need to install.

#+begin_src elisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+end_src

Now that we have these packaging configs set up, it should be much
simpler to do things like [[id:0915af96-9c96-452c-aa7d-a2d2dc9b6fdd][install Magit]].
*** Writing this document in org-mode
Meta, I know.

To get comfortable to start writing, I needed a few little things:
- [[id:3c07a0c6-e429-4213-9902-6ce6b6c6b929][Use a larger font]]
- [[id:33615063-5da3-4819-ae66-ab88c3106138][GUI elements: get rid of ones I don't like, and add ones I like]]
- [[id:25248000-52aa-498a-81af-6e1f5275b64b][Make org-mode consistent across emacs versions]]
- [[id:622185b0-8934-439a-9630-72826b55a95b][Turn on word-wrapping and spell checking]]
- [[id:0179515c-2e43-4072-8708-87035583664d][Make org-mode source snippets work]]

Once I'm writing, I need three more:
- [[id:1cc584ba-f164-4481-b4e0-fc6388e70358][More sustainable org-mode hyperlinking]]
- [[id:0915af96-9c96-452c-aa7d-a2d2dc9b6fdd][Magit: an easy way to check things into git]]
- [[id:e83d211f-8c44-47ca-a81e-d61f1bce629f][Sensible file backups]]

**** Use a larger font
:PROPERTIES:
:ID:       3c07a0c6-e429-4213-9902-6ce6b6c6b929
:END:
I'm currently writing this on a 2008 Dell Latitude E6500, and the
default font on this screen is a bit small for me.

In future I will likely want to do something more clever here, but for
now, let's just assume that everyone likes bigger fonts.

The following is suggested [[info:emacs#Fonts][in the manual here]]:

#+begin_src elisp
  (add-to-list 'default-frame-alist
	       '(font . "DejaVu Sans Mono-14"))
#+end_src

**** GUI elements
:PROPERTIES:
:ID:       33615063-5da3-4819-ae66-ab88c3106138
:END:
When I'm writing, I prefer to use my whole screen for emacs, and to
interact using the keyboard. For me, the scroll bar, menu bar, and
tool bar take up space that I'd rather use for the content of what I'm
working on.

I can turn them off like this:

#+begin_src elisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

Since I'm using my whole screen for emacs, I usually can't see my
system clock. So I like to display one on the emacs modeline.

#+begin_src elisp
(display-time-mode t)
#+end_src

I also like to see line numbers by the side of the screen, and the
column number in my mode-line. The line numbers are great when
collaborating, so folks can say things like "you've got a typo on line
30", and the column numbers are occasionally useful for formatting
things.

#+begin_src elisp
  (global-display-line-numbers-mode t)
  (column-number-mode t)
#+end_src

**** Make org-mode consistent across emacs versions
:PROPERTIES:
:ID:       25248000-52aa-498a-81af-6e1f5275b64b
:END:
The machine I'm beginning this document on has the latest slackware
emacs package installed -- and that is version 27.2. On my ubuntu work
machine, I have emacs 28.

Starting in emacs 28, the default value of the =org-adapt-indentation=
variable has changed from =t= to (IIRC) =nil=. I prefer the new
behaviour, so that's what I'm setting here.

#+begin_src elisp
(setq org-adapt-indentation nil)
#+end_src

This means that the text paragraphs in this document won't try to
indent themselves to match the heading level. They will all stick at 0
indentation by default. This makes copy-pasting from one section to
another much easier.

**** Turn on word-wrapping and spell-checking
:PROPERTIES:
:ID:       622185b0-8934-439a-9630-72826b55a95b
:END:

When editing text, or text-derived things like markdown or org files,
I like to have a sensible word-wrap, and a spell checker.

In emacs, word wrapping is provided by a function called
=auto-fill-mode=, and spellchecking by =flyspell-mode=. We can add
these to all text and text-derived modes by using the =text-mode-hook=.

#+begin_src elisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (ispell-change-dictionary "british" t) ; of course
  (add-hook 'text-mode-hook 'flyspell-mode)
#+end_src

Since markdown-mode, org-mode, latex-mode and so on are all derived
from text-mode, this will do the job for all those sorts of files too.

The =t= in =ispell-change-dictionary= is so that we use a British
dictionary globally, not just in a single buffer. 

***** Historical Detour

****** Why =flyspell-mode= and not =spellcheck-mode= or similar?
This is because emacs has had a spell-checker for a very long time --
far longer than it's been practical to keep one running in the
background as we enter text. 

When I started using emacs, the usual way to spellcheck the current
buffer was with =ispell-buffer=, which shelled out to the unix
=ispell= program (and later, =aspell=, because people like to write
improved versions of things) to do the actual checking. In fact, I
still sometimes use the command =M-$= (=ispell-word=) to check the
spelling of a single word if I'm unsure.

The emacs help system [[help:ispell-buffer][tells me]] that =ispell-buffer= was "[p]robably
introduced at or before Emacs version 19.20", and links to
[[file:/usr/share/emacs/27.2/etc/NEWS.19::To check the entire current buffer, use M-x ispell-buffer.][the relevant section of the emacs news file for version 19]]. It's worth
noting that before =ispell-buffer= was introduced, the =M-$= command
already existed, and used the unix =spell= program. I guess =ispell=
stands for =interactive spell=, and provides a better UX on the
command line.

Anyway, since the default way to check spelling used to be with
=ispell=, the idea of spell-checking on the fly sounds like it ought
to be called =flyspell=.

****** Why =auto-fill-mode= and not =word-wrap-mode= or similar?
Because auto-fill-mode doesn't /just/ wrap words. It can also do other
typesetting tricks.

The easiest way to see this in action is to play with =M-q=
(=fill-paragraph=). Start by writing some poorly formatted text:

#+begin_src fundamental
  Here is
  some text
     which I haven't formatted in the usual
  way.
  If this were     clever poetry, perhaps this would be excusable. But
  it's not.   It's
  just me writing text with                 weird
  spacing and
  line   breaks.
#+end_src

Now, if you put your cursor anywhere in that text, and hit =M-q=, this
happens:
#+begin_src fundamental
  Here is some text which I haven't formatted in the usual way.  If this
  were clever poetry, perhaps this would be excusable. But it's not.
  It's just me writing text with weird spacing and line breaks.
#+end_src

This is very handy. Notice that we haven't just removed the line
breaks and re-wrapped the text. We've got rid of *all* the whitespace,
and re-wrapped the text. This still isn't quite =filling= though. 

Now put the cursor anywhere in that text, and hit =C-u M-$=:
#+begin_src fundamental
  Here is some text which I haven't formatted in the usual way.  If this
  were clever  poetry, perhaps  this would be  excusable. But  it's not.
  It's just me writing text with weird spacing and line breaks.
#+end_src

Now the text has not only been wrapped, it has also been
*justified*. See how the two full lines end at exactly the same
column? This looks a little more like newspaper print.

If we were assembling this text on a printing press, then to achieve
the /justified/ look, we would have to artistically fill in the gaps
between words with whitespace. This is "filling". Hence
=fill-paragraph=, and =auto-fill-mode=.

There is lots more cleverness that emacs can do with filling. You can
read about it [[info:emacs#Filling][in the manual here]].

**** Make org-mode source snippets work
:PROPERTIES:
:ID:       0179515c-2e43-4072-8708-87035583664d
:END:
When writing a file like this, I find myself repeating the following
boilerplate quite a lot:

#+begin_example
#+begin_src elisp
... some code or other ...
#+end_src
#+end_example

That can get quite dull. Emacs provides the command =C-c C-,= (or
=org-insert-structure-template=) to help out with that boilerplate,
but it's even better to be able to use snippets like =< s <TAB>= to
create a code block.

To enable those snippets, we can require =org-tempo=:

#+begin_src elisp
(require 'org-tempo nil t)
#+end_src

In some versions of emacs (I think 28+ ?), this functionality is baked
into org-mode itself, so the require will fail. This is why we add the
=t= at the end of the call. That corresponds to the =NOERROR=
parameter of the =require= function. This way our startup isn't
aborted in the even that we never needed this line in the first place.

Read more about org structure templates and snippets in [[info:org#Structure Templates][the manual here]].

**** More sustainable org-mode hyperlinking
:PROPERTIES:
:ID:       1cc584ba-f164-4481-b4e0-fc6388e70358
:END:
In this document, I want to be able to hyperlink from one section to
another. For example, at the top of this use-case section, I have a
short list of upcoming subsections, each of which is hyperlinked.

In future I may want to split this file up into several smaller files,
and cross-link between them.

Org provides a few different ways of linking to other bits of
org-file. My favourite is [[info:org#Handling Links][to use =CUSTOM_ID= properties]]. The easiest
way to do this is to [[help:org-id-link-to-org-use-id][set the =org-id-link-to-org-use-id= variable]] to
non-nil, and then to [[help:org-store-link][bind the =org-store-link= function]] to a useful
key:

#+begin_src elisp
(require 'org-id)
(setq org-id-link-to-org-use-id t)
(global-set-key (kbd "C-c l") 'org-store-link)
#+end_src

Now, any time my cursor is pointing at something which I'd like to
hyperlink to later, I can hit =C-c l=, to save that link. Then I can
navigate back to my document, highlight the text I want to link from,
and hit =C-c C-l <RET>= to make the link.

If the thing I'm linking to is a section in an org-document, the act
of storing the link will cause a =CUSTOM_ID= property to be
created. For example, this section currently begins like this:

#+begin_src fundamental
,**** More sustainable org-mode hyperlinking
In this document, I want to be able to hyperlink from one section to
another...
#+end_src

But if I hit =C-c l=, then an ID property gets created like so:

#+begin_src fundamental
,**** More sustainable org-mode hyperlinking
:PROPERTIES:
:ID:       1cc584ba-f164-4481-b4e0-fc6388e70358
:END:
In this document, I want to be able to hyperlink from one section to
another...
#+end_src

Now I can create [[id:1cc584ba-f164-4481-b4e0-fc6388e70358][a link]] which looks like this:
#+begin_src fundamental
... create [[id:1cc584ba-f164-4481-b4e0-fc6388e70358][a link]] which looks like...
#+end_src

Notice that we're linking to the ID, which org will try to keep as
close to globally unique as possible. We are *not* relying on any kind of
tree path or headline naming scheme to make the hyperlink work. This
means:
- I can re-name this section, and the link will still work.
- I can move this section to another part of the document, and the
  link will still work.

**** Magit: an easy way to check things into git
:PROPERTIES:
:ID:       0915af96-9c96-452c-aa7d-a2d2dc9b6fdd
:END:
I'm keeping these configs in git, and it's nice to be able to manage
git from within emacs. There is a clear winner when it comes to
emacs-git workflows, and that is to [[https://magit.vc/manual/magit/][use magit]].

Getting magit into emacs is easy if [[id:52f1be7b-2b15-4b4c-84fa-ece5e2437c7b][we've already set up
=melpa-stable= and =use-package=]].

#+begin_src elisp
  (use-package magit
	       :ensure t
	       :commands (magit-status)
	       :bind (("C-x g" . magit-status)))
#+end_src

I won't write here about using magit, since the magit info page is
excellent.

However, I do need to be able to sign my commits with GPG. For this to
work with magit, I need to be able to enter GPG passphrases through
emacs. This is possible with the pinentry package.

#+begin_src emacs-lisp
  (use-package pinentry
    :ensure t)
  (pinentry-start)
#+end_src

**** Sensible file backups
:PROPERTIES:
:ID:       e83d211f-8c44-47ca-a81e-d61f1bce629f
:END:
By default, if we're editing a file called =somefile.file=, emacs
will often create a backup file =somefile.file~= of what that file
/used/ to look like before we started messing with it.

This is a pretty good idea, and has saved me from a few ill-advised
edits that would otherwise have broken stuff over the years. However,
it does leave my filesystem looking a little cluttered, and risks me
accidentally checking backups into git.

We can customise this behaviour to keep all the backups in one place,
out of the way of my git repos and so on. I'm going to put them in my
=~/.saves= directory. I'm also going to tell emacs to keep more than
one old version of a given file, and to limit things to 6 backups per
file:

#+begin_src elisp
     (setq
	backup-by-copying t
	backup-directory-alist
	 '(("." . "~/.saves"))
	version-control t
	delete-old-versions t
	kept-new-versions 4
	kept-old-versions 2)
#+end_src

For more on this backup mechanism, and how these variables affect it,
see [[info:emacs#Backup][the backup files section of the emacs manual]].

*** Setting up [[https://xmonad.org][xmonad]]

Xmonad is a tiling window manager, which I have some fondness
for. After the [[https://en.wikipedia.org/wiki/Wmii][sadly now defunct wmii]], it was the first tiling WM I
ever used.

The [[https://xmonad.org][xmonad page]] recommends that we install it using our OS
package-manager. But in slackware, this feels like it might not be the
best option. There /is/ [[http://slackbuilds.org/][a slackbuild for it]], but the dependency-tree
quickly starts to feel a bit excessive.

I'd like to be able to code in haskell on this machine anyway, so I'm
going to follow the instructions for [[https://xmonad.org/INSTALL.html][building from source in
userspace]].

This will likely involve something like the following:

- Compilers etc: setting up GHC, cabal, stack, and so on.
- Editor: making haskell comfortable in emacs.
- Xmonad: installing and configuring the WM itself.

**** Compilers etc
:PROPERTIES:
:ID:       4b9c729c-d628-4bfd-9c03-c1d1b1830228
:END:
It seems that the modern way to install haskell in userspace is with a
[[https://www.haskell.org/ghcup/][tool called ghcup]]. This installs:
- GHC :: The compiler
- Cabal :: The original dependency management tool
- Stack :: Another dependency management tool
- HLS :: A language server which we can integrate with emacs, to build
  our IDE.

Installing ghcup, and thence all the above is as easy as running:
#+begin_src bash :eval never :tangle no
curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
#+end_src

**** Editor: haskell in emacs
Now that [[id:4b9c729c-d628-4bfd-9c03-c1d1b1830228][I have HLS installed]], I should hopefully be able to use it in
conjunction with emacs. The [[https://haskell-language-server.readthedocs.io/en/latest/#][docs for the HLS are here]]. In particular,
the [[https://haskell-language-server.readthedocs.io/en/latest/configuration.html#emacs][section on emacs]] says:
#+begin_quote
Emacs support is provided by a combination of the following packages:

lsp-mode lsp-ui lsp-haskell

You can install these manually if you are using plain Emacs; instructions for some specific flavours are
included below.
#+end_quote

Of these three, =lsp-mode= and =lsp-ui= are available on
=melpa-stable=, but =lsp-haskell= is not. It looks like [[https://melpa.org/#/lsp-haskell][lsp-haskell]] is
available on =melpa=, but I'd like to avoid those less stable packages
for now.

***** TODO Come back to lsp-haskell later, and see if it's on melpa-stable yet.

***** Installing a stable haskell mode
According to [[https://wiki.haskell.org/Emacs][the haskell wiki]] "haskell-mode is stable and usable,
whereas lsp-haskell is newer but under development and not ready for
general use".

So I guess we want =haskell-mode=, which [[https://github.com/haskell/haskell-mode#start-of-content][is on github here]], and should
be quite simple to [[*Installing emacs packages][get with use-package]]:
#+begin_src elisp
  (use-package haskell-mode
    :ensure t)
#+end_src

**** Xmonad: installing and configuring the WM
The installation instructions [[https://xmonad.org/INSTALL.html][are here]].

Following them is pretty straightforward. We create a
=~/.config/xmonad= directory; clone =xmonad= and =xmonad-contrib=, and
check out the latest tags; and create a simple default =xmonad.hs=.

I'm going with /almost/ the bare default -- but I'm setting the main
modifier key to one that doesn't clash with emacs, and the terminal
to something nicer than a bare xterm:

#+begin_src haskell :tangle no :eval never
import XMonad

main :: IO ()
main = xmonad $ def
       { modMask = mod4Mask             -- Rebind Mod to the Super key
       , terminal = "urxvt -rv +sb -ls" -- Set terminal to a simple
                                        -- dark unicode rxvt login
                                        -- shell
       }
#+end_src

I created the directory using [[info:emacs#Dired][Dired]]. I opened =~/.config= using =C-x
C-f=, and used =+= to add a new directory, which I named =xmonad= at
the prompt. This gave me a buffer representing my =xmonad= directory,
where I could use =M-&= (=async-shell-command=) to run the =git clone=
operations.

Finally, I can use the same =M-&= command to run =stack init=, which
creates a build script, and =stack install=, which installs =xmonad=
in =~/.local/bin=.

I can call this binary with an =exec xmonad= line in my =~/.xinitrc=.

*** Editing bash scripts
Emacs comes with [[file:/usr/share/emacs/27.2/lisp/progmodes/sh-script.el.gz::(define-derived-mode sh-mode prog-mode "Shell-script"][sh-mode]] by default, and this is pretty good for bash
and sh scripts.

I like to add [[https://www.shellcheck.net/][shellcheck]] to my system too. Shellcheck is a tool (a
linter) which checks shell scripts for common errors before you've run
them. In a dynamically typed language like bash -- and especially one
so esoteric as bash -- it can be a lifesaver.

As [[https://www.shellcheck.net/][the shellcheck home page]] says, you can install shellcheck using
cabal, apt, dnf, pkg or brew. I'll be using sbopkg to install [[http://slackbuilds.org/repository/15.0/development/ShellCheck-bin/][the
slackbuild]].

**** Using shellcheck with vanilla emacs

Once I have shellcheck installed, I can use it with vanilla-emacs
using the =M-x compile= command. For example, while editing my
=.xinitrc= I might run =M-x compile= then =shellcheck -f gcc
.xinitrc=. This gives me a new window that looks something like the
following:

#+begin_src compilation
-*- mode: compilation; default-directory: "~/" -*-
Compilation started at Fri Aug 12 09:09:21

shellcheck -f gcc .xinitrc
.xinitrc:21:9: note: Double quote to prevent globbing and word splitting. [SC2086]
.xinitrc:22:17: note: Double quote to prevent globbing and word splitting. [SC2086]
.xinitrc:25:9: note: Double quote to prevent globbing and word splitting. [SC2086]
.xinitrc:26:13: note: Double quote to prevent globbing and word splitting. [SC2086]
.xinitrc:33:6: warning: Quote this to prevent word splitting. [SC2046]

Compilation exited abnormally with code 1 at Fri Aug 12 09:09:21
#+end_src

Notice that I told shellcheck to give me errors in the same format at
gcc when I specified =-f gcc=. This is a format that emacs recognises,
so my compilation window gets sensible syntax highlighting and
hyperlinking. If I hit =<RETURN>= on any of the error messages, my
cursor will jump straight to the point in my source file that
generated the error.

When I think I've fixed my errors, I can re-run shellcheck by hitting
=g= in the compilation window.

To read more about emacs' compilation mode, [[info:emacs#Compilation][see this info page]].

This isn't a bad user-experience, but we can do better.

**** Getting on-the-fly checking

To make this integrate with emacs, we can use the [[http://www.flycheck.org/en/latest/][flycheck]] package:

#+BEGIN_SRC emacs-lisp
;  (use-package flycheck
;    :ensure t
;    :delight
;    :commands flycheck-mode)
#+END_SRC

...or the built-in [[info:flymake#Top][flymake]]...

***** Plan:

****** TODO use [[info:ert#Introduction][ERT]] to write tests for the [[info:flymake#Backend functions][flymake backend function]]
Maybe keep them in here, but tangle them to another file?

Maybe show some incremental development in =:tangle no= blocks?

#+begin_src elisp
  (ert-deftest gds-shellcheck-no-errors ()
    "Shellcheck finds no errors in a perfect script."
    ;; Create a spy report-function
    ;; Open a perfect script (test fixture)
    ;; Call gds-flymake-shellcheck
    ;; Wait for report function to say something about finishing?
    ;; Check that no errors were reported.
  )

  (ert-deftest gds-shellcheck-some-errors ()
    "Shellcheck finds the right errors in a buggy script."
    ;; Create a spy report-function
    ;; Open a buggy script (test fixture)
    ;; Call gds-flymake-shellcheck
    ;; Wait for report function to say something about finishing?
    ;; Check that the right errors were reported.
  )

#+end_src


****** TODO Write the flymake back end function
#+begin_src elisp
  (defun gds-flymake-shellcheck (report-fn &rest keylist)
  
  )

  (add-hook 'flymake-diagnostic-functions 'gds-flymake-shellcheck)
#+end_src

**** TODO Tie the backend function in

#+begin_src elisp
(add-hook 'flymake-diagnostic-functions `gds-flymake-shellcheck)
#+end_src

*** TODO Keep track of bookmarks
:PROPERTIES:
:ID:       d5067eea-4bcc-4839-80a6-ba05d4214a42
:END:
Emacs' [[info:org#Top][org-mode]] gives us an excellent way of keeping track of
bookmarks, using its [[info:org#Capture][capture function]]. 

If we keep a bookmarks org file in [[https://www.dropbox.com/][dropbox]], we can add bookmarks to it
using an org capture template:
#+begin_src elisp
  (setq org-capture-templates
	'(
	  ("b" "Bookmark" entry 
	   (file "~/Dropbox/Documents/Orgzly/bookmarks.org")
	   "* %:annotation \n%i"
	   :immediate-finish t)))
#+end_src

...and we can capture bookmarks with =C-c c b=

#+begin_src elisp
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src

**** TODO rsync instead of dropbox?

*** TODO Browsing the web

#+begin_src elisp
(setq browse-url-browser-function 'eww-browse-url)
#+end_src

*** TODO Email

Trying the MH-E framework, and the MH suite from the gnu mailutils
package.

This means installing the following slackbuilds:
- libgsasl
- mailutils



*** TODO Put the control key in a more comfortable place

**** TODO using xmodmap for X

#+begin_src xmodmap
keycode 66 = Control_L
clear Lock
add Control = Control_L
#+end_src

**** TODO also in the console!

Looks like this will be something to do with loadkeys. Try =man
loadkeys= or =man 5 keymaps=.

Also =/usr/share/kbd=. Possibly we have to edit
=/usr/share/kbd/keymaps/i386/qwerty/uk.map.gz=

By default, the bottom of this file looks like:

#+begin_example
keycode  28 = Return
	alt	keycode  28 = Meta_Control_m
keycode  29 = Control
keycode  39 = semicolon        colon
keycode  40 = apostrophe       at
	control	keycode  40 = Control_g
	shift	control	keycode  40 = nul
keycode  41 = grave            notsign          bar              nul
keycode  42 = Shift
keycode  43 = numbersign       asciitilde
	control	keycode  43 = Control_backslash
keycode  51 = comma            less
keycode  52 = period           greater
keycode  53 = slash            question
	control	keycode  53 = Delete
keycode  54 = Shift
keycode  56 = Alt
keycode  57 = space
	control	keycode  57 = nul
keycode  58 = Caps_Lock
keycode  86 = backslash        bar              bar              Control_backslash
keycode  97 = Control
#+end_example

Let's change it to swap =Caps_Lock= out for =Control=, and see if that
breaks everything.

#+begin_example
keycode  28 = Return
	alt	keycode  28 = Meta_Control_m
keycode  29 = Control
keycode  39 = semicolon        colon
keycode  40 = apostrophe       at
	control	keycode  40 = Control_g
	shift	control	keycode  40 = nul
keycode  41 = grave            notsign          bar              nul
keycode  42 = Shift
keycode  43 = numbersign       asciitilde
	control	keycode  43 = Control_backslash
keycode  51 = comma            less
keycode  52 = period           greater
keycode  53 = slash            question
	control	keycode  53 = Delete
keycode  54 = Shift
keycode  56 = Alt
keycode  57 = space
	control	keycode  57 = nul
keycode  58 = Control
keycode  86 = backslash        bar              bar              Control_backslash
keycode  97 = Control
#+end_example
