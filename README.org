* Emacs Configs

These are my personal emacs configs. In this branch, I'm trying a
minimalist setup, where every configuration choice is driven by a
use-case in this document.

This document is primarily. intended to be read in emacs, so some
hyperlinks may not work if you're reading in a web browser. For
example, I often link to internal emacs docs, help pages, and info
pages.

** Use Cases
*** Installing emacs packages
:PROPERTIES:
:ID:       52f1be7b-2b15-4b4c-84fa-ece5e2437c7b
:END:
While emacs ships with an enormous amount of cool stuff out of the
box, there are some extras we might want to install as well. For
example, [[id:0915af96-9c96-452c-aa7d-a2d2dc9b6fdd][we'd like to install Magit]].

Fortunately, emacs has [[info:emacs#Packages][a built in package management system]]. It can
download and install packages from a customisable list of /package
archives/, which are defined in the =package-archives= variable. By
default, that variable looks like this:
#+begin_src elisp :tangle no
(("gnu" . "https://elpa.gnu.org/packages/"))
#+end_src

This means we can download from the official gnu Emacs List Package
Archive (elpa). However, the bar for getting a package in there is
quite high, so we will often want to install from /Milkypostmanâ€™s
Emacs Lisp Package Archive/, or =melpa=.

There are two =melpa= archives, =melpa.org= and
=stable.melpa.org=. The former was the original =melpa=, but suffered
from packages that kept breaking in various ways. The stable archive
was introduced for folks who want to live a little less on the
bleeding edge. Generally speaking, packages in =melpa-stable= have
semantic version numbers, while packages in =melpa= are organised by
release-date rather than by version.

If possible I'd like to stick to the stable archive.

#+begin_src elisp
(require 'package)
(add-to-list 'package-archives
             '("melpa-stable" . "http://stable.melpa.org/packages/") t)
#+end_src

Now that we have access to a wider range of packages, we can install
things. However, doing so in code has a number of tedious edge-cases,
which are best handled by the =use-package= library. Which we will
first need to install.

#+begin_src elisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+end_src

Now that we have these packaging configs set up, it should be much
simpler to do things like [[id:0915af96-9c96-452c-aa7d-a2d2dc9b6fdd][install Magit]].
*** Writing this document in org-mode
Meta, I know.

To get comfortable to start writing, I needed a few little things:
- [[id:96936ca1-0ed9-44e5-8006-c74ff1673eb3][Use a dark theme]]
- [[id:3c07a0c6-e429-4213-9902-6ce6b6c6b929][Use a larger font]]
- [[id:33615063-5da3-4819-ae66-ab88c3106138][GUI elements: get rid of ones I don't like, and add ones I like]]
- [[id:25248000-52aa-498a-81af-6e1f5275b64b][Make org-mode consistent across emacs versions]]
- [[id:622185b0-8934-439a-9630-72826b55a95b][Turn on word-wrapping and spell checking]]
- [[id:0179515c-2e43-4072-8708-87035583664d][Make org-mode source snippets work]]

Once I'm writing, I need two more:
- [[id:1cc584ba-f164-4481-b4e0-fc6388e70358][More sustainable org-mode hyperlinking]]
- [[id:0915af96-9c96-452c-aa7d-a2d2dc9b6fdd][Magit: an easy way to check things into git]]

**** Use a dark theme
:PROPERTIES:
:ID:       96936ca1-0ed9-44e5-8006-c74ff1673eb3
:END:
Emacs in the GUI uses a light theme by default. I prefer a dark
one. The =wheatgrass= theme comes with emacs, and is dark.

#+begin_src elisp
(load-theme 'wheatgrass t)
#+end_src

The optional =t= means we don't ask the user interactively to check
that it's ok to run the elisp in the theme code. I'm trusting it
because it ships with emacs.

**** Use a larger font
:PROPERTIES:
:ID:       3c07a0c6-e429-4213-9902-6ce6b6c6b929
:END:
I'm currently writing this on a 2008 Dell Latitude E6500, and the
default font on this screen is a bit small for me.

In future I will likely want to do something more clever here, but for
now, let's just assume that everyone likes bigger fonts.

The following is suggested [[info:emacs#Fonts][in the manual here]]:

#+begin_src elisp
  (add-to-list 'default-frame-alist
	       '(font . "DejaVu Sans Mono-14"))
#+end_src

**** GUI elements
:PROPERTIES:
:ID:       33615063-5da3-4819-ae66-ab88c3106138
:END:
When I'm writing, I prefer to use my whole screen for emacs, and to
interact using the keyboard. For me, the scroll bar, menu bar, and
tool bar take up space that I'd rather use for the content of what I'm
working on.

I can turn them off like this:

#+begin_src elisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

Since I'm using my whole screen for emacs, I usually can't see my
system clock. So I like to display one on the emacs modeline.

#+begin_src elisp
(display-time-mode t)
#+end_src

I also like to see line numbers by the side of the screen, and the
column number in my mode-line. The line numbers are great when
collaborating, so folks can say things like "you've got a typo on line
30", and the column numbers are occasionally useful for formatting
things.

#+begin_src elisp
  (global-display-line-numbers-mode t)
  (column-number-mode t)
#+end_src

**** Make org-mode consistent across emacs versions
:PROPERTIES:
:ID:       25248000-52aa-498a-81af-6e1f5275b64b
:END:
The machine I'm beginning this document on has the latest slackware
emacs package installed -- and that is version 27.2. On my ubuntu work
machine, I have emacs 28.

Starting in emacs 28, the default value of the =org-adapt-indentation=
variable has changed from =t= to (IIRC) =nil=. I prefer the new
behaviour, so that's what I'm setting here.

#+begin_src elisp
(setq org-adapt-indentation nil)
#+end_src

This means that the text paragraphs in this document won't try to
indent themselves to match the heading level. They will all stick at 0
indentation by default. This makes copy-pasting from one section to
another much easier.

**** Turn on word-wrapping and spell-checking
:PROPERTIES:
:ID:       622185b0-8934-439a-9630-72826b55a95b
:END:

When editing text, or text-derived things like markdown or org files,
I like to have a sensible word-wrap, and a spell checker.

In emacs, word wrapping is provided by a function called
=auto-fill-mode=, and spellchecking by =flyspell-mode=. We can add
these to all text and text-derived modes by using the =text-mode-hook=.

#+begin_src elisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (ispell-change-dictionary "british" t) ; of course
  (add-hook 'text-mode-hook 'flyspell-mode)
#+end_src

Since markdown-mode, org-mode, latex-mode and so on are all derived
from text-mode, this will do the job for all those sorts of files too.

The =t= in =ispell-change-dictionary= is so that we use a British
dictionary globally, not just in a single buffer. 

***** Historical Detour

****** Why =flyspell-mode= and not =spellcheck-mode= or similar?
This is because emacs has had a spell-checker for a very long time --
far longer than it's been practical to keep one running in the
background as we enter text. 

When I started using emacs, the usual way to spellcheck the current
buffer was with =ispell-buffer=, which shelled out to the unix
=ispell= program (and later, =aspell=, because people like to write
improved versions of things) to do the actual checking. In fact, I
still sometimes use the command =M-$= (=ispell-word=) to check the
spelling of a single word if I'm unsure.

The emacs help system [[help:ispell-buffer][tells me]] that =ispell-buffer= was "[p]robably
introduced at or before Emacs version 19.20", and links to [[file:/usr/share/emacs/27.2/etc/NEWS.19::To check the entire current buffer, use M-x ispell-buffer.][the
relevant section of the emacs news file for version 19]]. It's worth
noting that before =ispell-buffer= was introduced, the =M-$= command
already existed, and used the unix =spell= program. I guess =ispell=
stands for =interactive spell=, and provides a better UX on the
command line.

Anyway, since the default way to check spelling used to be with
=ispell=, the idea of spell-checking on the fly sounds like it ought
to be called =flyspell=.

****** Why =auto-fill-mode= and not =word-wrap-mode= or similar?
Because auto-fill-mode doesn't /just/ wrap words. It can also do other
typesetting tricks.

The easiest way to see this in action is to play with =M-q=
(=fill-paragraph=). Start by writing some poorly formatted text:

#+begin_src fundamental
  Here is
  some text
     which I haven't formatted in the usual
  way.
  If this were     clever poetry, perhaps this would be excusable. But
  it's not.   It's
  just me writing text with                 weird
  spacing and
  line   breaks.
#+end_src

Now, if you put your cursor anywhere in that text, and hit =M-q=, this
happens:
#+begin_src fundamental
  Here is some text which I haven't formatted in the usual way.  If this
  were clever poetry, perhaps this would be excusable. But it's not.
  It's just me writing text with weird spacing and line breaks.
#+end_src

This is very handy. Notice that we haven't just removed the line
breaks and re-wrapped the text. We've got rid of *all* the whitespace,
and re-wrapped the text. This still isn't quite =filling= though. 

Now put the cursor anywhere in that text, and hit =C-u M-$=:
#+begin_src fundamental
  Here is some text which I haven't formatted in the usual way.  If this
  were clever  poetry, perhaps  this would be  excusable. But  it's not.
  It's just me writing text with weird spacing and line breaks.
#+end_src

Now the text has not only been wrapped, it has also been
*justified*. See how the two full lines end at exactly the same
column? This looks a little more like newspaper print.

If we were assembling this text on a printing press, then to achieve
the /justified/ look, we would have to artistically fill in the gaps
between words with whitespace. This is "filling". Hence
=fill-paragraph=, and =auto-fill-mode=.

There is lots more cleverness that emacs can do with filling. You can
read about it [[info:emacs#Filling][in the manual here]].

**** Make org-mode source snippets work
:PROPERTIES:
:ID:       0179515c-2e43-4072-8708-87035583664d
:END:
When writing a file like this, I find myself repeating the following
boilerplate quite a lot:

#+begin_example
#+begin_src elisp
... some code or other ...
#+end_src
#+end_example

That can get quite dull. Emacs provides the command =C-c C-,= (or
=org-insert-structure-template=) to help out with that boilerplate,
but it's even better to be able to use snippets like =< s <TAB>= to
create a code block.

To enable those snippets, we can require =org-tempo=:

#+begin_src elisp
(require 'org-tempo nil t)
#+end_src

In some versions of emacs (I think 28+ ?), this functionality is baked
into org-mode itself, so the require will fail. This is why we add the
=t= at the end of the call. That corresponds to the =NOERROR=
parameter of the =require= function. This way our startup isn't
aborted in the even that we never needed this line in the first place.

Read more about org structure templates and snippets in [[info:org#Structure Templates][the manual here]].

**** More sustainable org-mode hyperlinking
:PROPERTIES:
:ID:       1cc584ba-f164-4481-b4e0-fc6388e70358
:END:
In this document, I want to be able to hyperlink from one section to
another. For example, at the top of this use-case section, I have a
short list of upcoming subsections, each of which is hyperlinked.

In future I may want to split this file up into several smaller files,
and cross-link between them.

Org provides a few different ways of linking to other bits of
org-file. My favourite is [[info:org#Handling Links][to use =CUSTOM_ID= properties]]. The easiest
way to do this is to [[help:org-id-link-to-org-use-id][set the =org-id-link-to-org-use-id= variable]] to
non-nil, and then to [[help:org-store-link][bind the =org-store-link= function]] to a useful
key:

#+begin_src elisp
(setq org-id-link-to-org-use-id t)
(global-set-key (kbd "C-c l") 'org-store-link)
#+end_src

Now, any time my cursor is pointing at something which I'd like to
hyperlink to later, I can hit =C-c l=, to save that link. Then I can
navigate back to my document, highlight the text I want to link from,
and hit =C-c C-l <RET>= to make the link.

If the thing I'm linking to is a section in an org-document, the act
of storing the link will cause a =CUSTOM_ID= property to be
created. For example, this section currently begins like this:

#+begin_src fundamental
,**** More sustainable org-mode hyperlinking
In this document, I want to be able to hyperlink from one section to
another...
#+end_src

But if I hit =C-c l=, then an ID property gets created like so:

#+begin_src fundamental
,**** More sustainable org-mode hyperlinking
:PROPERTIES:
:ID:       1cc584ba-f164-4481-b4e0-fc6388e70358
:END:
In this document, I want to be able to hyperlink from one section to
another...
#+end_src

Now I can create [[id:1cc584ba-f164-4481-b4e0-fc6388e70358][a link]] which looks like this:
#+begin_src fundamental
... create [[id:1cc584ba-f164-4481-b4e0-fc6388e70358][a link]] which looks like...
#+end_src

Notice that we're linking to the ID, which org will try to keep as
close to globally unique as possible. We are *not* relying on any kind of
tree path or headline naming scheme to make the hyperlink work. This
means:
- I can re-name this section, and the link will still work.
- I can move this section to another part of the document, and the
  link will still work.

**** TODO Magit: an easy way to check things into git
:PROPERTIES:
:ID:       0915af96-9c96-452c-aa7d-a2d2dc9b6fdd
:END:
I'm keeping these configs in git, and it's nice to be able to manage
git from within emacs. There is a clear winner when it comes to
emacs-git workflows, and that is to [[https://magit.vc/manual/magit/][use magit]].

Getting magit into emacs is easy if [[id:52f1be7b-2b15-4b4c-84fa-ece5e2437c7b][we've already set up
=melpa-stable= and =use-package=]].

#+begin_src elisp
  (use-package magit
	       :ensure t
	       :commands (magit-status)
	       :bind (("C-x g" . magit-status)))
#+end_src

I won't write here about using magit, since the magit info page is
excellent.

However, I do need to be able to sign my commits with GPG. For this to
work with magit, I need to be able to enter GPG passphrases through
emacs. This is possible with the pinentry package.

#+begin_src emacs-lisp
  (use-package pinentry
    :ensure t)
  (pinentry-start)
#+end_src


